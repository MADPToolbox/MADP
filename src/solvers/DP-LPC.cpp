/* This file is part of the Multiagent Decision Process (MADP) Toolbox v0.3. 
 *
 * The majority of MADP is free software released under GNUP GPL v.3. However,
 * some of the included libraries are released under a different license. For 
 * more information, see the included COPYING file. For other information, 
 * please refer to the included README file.
 *
 * This file has been written and/or modified by the following people:
 *
 * Abdeslam Boularias   (original implementation)
 * Frans Oliehoek       (MADP port)
 *
 * For contact information please see the included AUTHORS file.
 */

#define CHECK_RESULT 0

#include <time.h>
#include <sys/times.h>
#include <iostream>
#include <fstream>
#include <float.h>
#include "MADPParser.h"
#include "directories.h"
#include "DecPOMDPDiscrete.h"
#include "Timing.h"
#include "OptimalValueDatabase.h"


// Switch that controls whether the value of the solution will be
// computed, which takes times. This also enables the pruning of
// dominated policies for the last time step (otherwise value
// calculation is slow).
#define COMPUTE_VALUE 1

#include "argumentHandlers.h"
#include "argumentUtils.h"

using namespace std;
using namespace ArgumentUtils;

const char *argp_program_version = "DP-LPC";

// Program documentation
static char doc[] = "DP-LPC - runs Abdeslam Boularias's Dynamic Programming with Lossless Policy Compression  \
\v";

//NOTE: make sure that the below value (nrChildParsers) is correct!
const int nrChildParsers = 5;
const struct argp_child childVector[] = {
    ArgumentHandlers::problemFile_child,
    ArgumentHandlers::globalOptions_child,
    ArgumentHandlers::outputFileOptions_child,
    ArgumentHandlers::modelOptions_child,
    ArgumentHandlers::solutionMethodOptions_child,
    {0}
};

#include "argumentHandlersPostChild.h"


#include "sys/timeb.h"

#include <iostream>
using namespace std;










#if HAVE_CPLEX

#include <ilcplex/ilocplex.h>
ILOSTLBEGIN

/* Let's think about these sequence numbers....
 * Dec-Tiger 
 *  h=1:
 *      3 sequences per agent (3 actions)
 *      1 per policy
 *
 *  h=2:
 *      3*2*3 = 18 seqs per agent
 *      2 per policy (one for HL, and one for HR, ...?)
 *
 *  h=3:
 *      3*2*3*2*3 = 18 * 6 = 108 seqs per agent
 *      2 * 2 = 4 per policy?
 *
 *  h=4
 *      108 * 6 = 648
 *      2^3 = 8
 */      
size_t maxSequencesNumber;
size_t maxSequencesPerPolicyNumber;
size_t maxStatesNumber;
//#define maxSequencesNumber 650
//#define maxSequencesPerPolicyNumber 50
//#define maxStatesNumber 4

void ComputeSeqsNumbers(const DecPOMDPDiscreteInterface& d, int horizon)
{
    size_t max_actions=0;
    size_t max_obs=0;
    for(Index agI=0; agI < d.GetNrAgents(); agI++)
    {
        if (d.GetNrActions(agI) > max_actions)
            max_actions = d.GetNrActions(agI);
        if (d.GetNrObservations(agI) > max_obs)
            max_obs = d.GetNrObservations(agI);
    }
    size_t nrASeqs = pow(max_actions, horizon);
    size_t nrOSeqs = pow(max_obs, horizon-1);
    printf( "nrASeqs: %d, nrOSeqs: %d", nrASeqs, nrOSeqs);
    maxSequencesNumber = nrASeqs * nrOSeqs;
    maxSequencesPerPolicyNumber = nrOSeqs;
    maxStatesNumber = d.GetNrStates();
}


typedef struct policyType	// Define an individual policy
{
    int index;
    int action;			// The first action associated to the policy
    struct policyType **subPolicyIndex;	// The policies associated to each observation generated by the
    // action of the policy
    struct policyType *next;	// Index of the next policy
    int sequencesNumber;

    //FRANS cannot determine maxSequencesPerPolicyNumber at compile time!!!:
    //int sequencesList[maxSequencesPerPolicyNumber];
    int *sequencesList;
    policyType()
    {
        sequencesList = new int[maxSequencesPerPolicyNumber];
    }
    ~policyType()
    {
        delete [] sequencesList;
    }
} policyType;

typedef struct policyListType
{
    struct policyType *policy;
    struct policyListType *next;
} policyListType;

typedef struct sequenceType	// Define an individual sequence
{
    int index;
    int action;			// The first action in the sequence
    int observation;		// The observation following the action
    struct sequenceType *subSequence;
    int policiesNumber;
} sequenceType;

void
displayPolicy (struct policyType *policy)
{
    printf ("( %d", policy->action);
    int i;
    for (i = 0; i < 2; i++)
    {
	if ((policy->subPolicyIndex) && (policy->subPolicyIndex[i]))
	    displayPolicy (policy->subPolicyIndex[i]);
    }
    printf ("), ");
}



void DPLPCrun(const DecPOMDPDiscreteInterface &decpomdp,
              ofstream *fp,
              Timing &Time,
              int horizon,
              const ArgumentHandlers::Arguments &args,
              const string &timingsFilename)
{
	Time.Start("Planning");


	/************************* Global parameters definition **********************************/
	int prunnedPoliciesNumber;	// Calculated after each horizon step, and decreased after each prunning of a policy
	int jointAction;	// Used to indicate a joint action
	int jointObservation;	// Used to indicate a joint observation
	int *policiesNumberList;	// Array indicating the number of policies available for each agent
	int finishedAgentsNumber;
	int jointPoliciesNumberSave;
	float otherPolicyValue;

	int beliefPointsNumber;
	float observationProba;
	policyType *policySet;	// point the first policy of a list of policies
	policyType *oldPolicySet;	// to save policySet
	policyType *nextPolicy;	// point a policy
	policyType *currentPolicy;
	policyType *minusPolicy;
	policyType *oldPolicy;
	policyType *bestPolicy;
	policyType *otherPolicy;

	policyType *bestPolicyI;
	policyType *bestPolicyJ;

	policyType **policySetsList;

	sequenceType *currentSequence;
	sequenceType *minusSequence;

	int *observationIndex;

	bool isDominated;
	bool isDependent;

	/************************* Other variables **************************************************/
	int i, j, k, l, m, n, a, depth, stop, constraintsLevel;
	float maxValue, value, value1;
	double probaSum;
	int problem;
	double targetValue;

	/************************ These are the only parameters you need to touch ******************/
	constraintsLevel = 2;
	float pruningThreshold = -0.02;	//
	/*******************************************************************************************/



	/************************ Solving the DEC-POMDP *******************************************/
/* 	vector< vector< vector<float> > >  temp;
        temp[i].resize(maxSequencesNumber);
        for(Index j=0; j < maxSequencesNumber; j++)
        {
            temp[i][j].resize(maxSequencesNumber);
            for(Index k=0; k < maxSequencesNumber; k++)
            {
                temp[i][j][k].resize(maxStatesNumber);
            }
        }
*/
	//static float valueVector[2][maxSequencesNumber][maxSequencesNumber][maxStatesNumber];
	//static float C[2][maxSequencesNumber][maxSequencesNumber][maxStatesNumber];
	static vector< vector< vector< vector<float> > > > valueVector(2);
	static vector< vector< vector< vector<float> > > > C(2);
        for(Index i=0; i < 2; i++)
        {
            valueVector[i].resize(maxSequencesNumber);
            C[i].resize(maxSequencesNumber);
            for(Index j=0; j < maxSequencesNumber; j++)
            {
                valueVector[i][j].resize(maxSequencesNumber);
                C[i][j].resize(maxSequencesNumber);
                for(Index k=0; k < maxSequencesNumber; k++)
                {
                    valueVector[i][j][k].resize(maxStatesNumber);
                    C[i][j][k].resize(maxStatesNumber);
                }
            }
        }
	//static struct sequenceType *sequencesList[2][2][maxSequencesNumber];
        static vector< vector< vector< sequenceType* > > >  sequencesList(2);
        cout << "maxSequencesNumber= " << maxSequencesNumber << endl;
        for(Index i=0; i < 2; i++)
        {
            sequencesList[i].resize(2);
            for(Index j=0; j < 2; j++)
            {
                sequencesList[i][j] =  vector< sequenceType* >(maxSequencesNumber) ;
                for(Index k=0; k < maxSequencesNumber; k++)
                    sequencesList[i][j][k] = 0;
            }
        }
        cout << "sequencesList[0][0][0] = " << sequencesList[0][0][0] << endl;

	vector < int >sequencesNumberList (2);	// for two agents
	vector < int >maxSequences (2);	// for two agents
	float U[50][50];

	struct timeb start;
	struct timeb end;
	ftime (&start);
	//srand(start.millitm);
	ftime (&start);

        Time.Start("SolveHorizon1");
        ///FRANS: -----------------------start horizon 1 -------------------------------------------------
        //-------------(i.e., create all seqs corresponding to individual actions) -----------------------
        
	//Generate the initial set of individual policies for horizon 1
        // Array containing the number of policies for each agent
	policiesNumberList = (int *) malloc (sizeof (int) * decpomdp.GetNrAgents ());	

	// Array indicating the first policy for each agent (A linear linked chaine)
	policySetsList = (policyType **) malloc (sizeof (struct policyType *) * decpomdp.GetNrAgents ());
        
	for (n = 0; n < decpomdp.GetNrAgents (); n++)
	{
	    policiesNumberList[n] = 0;
	    sequencesNumberList[n] = 0;
	    oldPolicy = NULL;
	    for (i = 0; i < decpomdp.GetNrActions (n); i++) 
	    {
                //FRANS: this loop seems to create a new sequence for agent n's i-th action...?
		//currentPolicy = (policyType *) malloc (sizeof (struct policyType));
		currentPolicy = new policyType();
		currentPolicy->subPolicyIndex = NULL;
		currentPolicy->action = i;
		// ********Add the sequence**********
		currentSequence = (sequenceType *) malloc (sizeof (struct sequenceType));
		currentSequence->action = i;
		currentSequence->index = sequencesNumberList[n];
		currentSequence->observation = -1;
		currentSequence->subSequence = NULL;
		currentSequence->policiesNumber = 1;
                cout << "sequencesList[0][0][0] = " << sequencesList[0][0][0] << endl;
		sequencesList[0][n][currentSequence->index] = currentSequence;
		sequencesNumberList[n]++;
		currentPolicy->sequencesNumber = 1;
		currentPolicy->sequencesList[0] = currentSequence->index;
		// **********************************
		if (oldPolicy)
		{
		    currentPolicy->index = oldPolicy->index + 1;
		    oldPolicy->next = currentPolicy;
		}
		else
		{
		    currentPolicy->index = 0;
		    policySetsList[n] = currentPolicy;
		}
		currentPolicy->next = NULL;
		oldPolicy = currentPolicy;
		policiesNumberList[n]++;
	    }
	}

	maxSequences[0] = sequencesNumberList[0];
	maxSequences[1] = sequencesNumberList[1];

	for (i = 0; i < maxSequences[0]; i++)
	{
	    for (j = 0; j < maxSequences[1]; j++)
	    {
		// Fill up the values of this joint sequence
		jointAction = (decpomdp.GetNrActions (0)) * (sequencesList[0][1][j]->action) + (sequencesList[0][0][i]->action);
		for (k = 0; k < decpomdp.GetNrStates (); k++)
		{
		    valueVector[0][i][j][k] = decpomdp.GetReward (k, jointAction);
		    C[0][i][j][k] = 1;
		}
	    }
	}

        //FRANS: the next part loops over agents  (indexed 'a') in order to prune dominated policies (iterated elim. of dominated policies), it 
        //ends when nothing can be pruned anymore
	a = 0;
	finishedAgentsNumber = 0;
	while (finishedAgentsNumber < decpomdp.GetNrAgents ())
	{
	    prunnedPoliciesNumber = 0;
	    // Prun the dominated policies for agent a
	    currentPolicy = policySetsList[a];
	    oldPolicy = NULL;
	    while (currentPolicy)
	    {
		// LP zone begin ***************************************************************************
		// Evaluation according to the sequential representation
		IloEnv env;
		IloModel lpModel (env);
		IloNumVarArray variables (env);
		IloNumExpr objectiveExpr (env);
		variables.add (IloNumVar (env, -IloInfinity, IloInfinity));
		objectiveExpr += variables[0];
		for (i = 1; i < 1 + decpomdp.GetNrStates () * sequencesNumberList[1 - a]; i++)
		    variables.add (IloNumVar (env, 0, 1));


                //FRANS: this fills 'variablesWeightsSaver', but not sure what it is exactly...?
		double *variablesWeightsSaver = (double *) malloc (sizeof (double) * (1 + decpomdp.GetNrStates () * sequencesNumberList[1 - a]));
		k = 0;
		for (i = 0; i < maxSequences[1 - a]; i++)
		{
		    if (sequencesList[0][1 - a][i] != NULL)
		    {
			for (m = 0; m < decpomdp.GetNrStates (); m++)
			{
			    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] = 0;
			    for (j = 0; j < currentPolicy->sequencesNumber; j++)
			    {
				if (a == 0) // if agent 0:
				    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] +=
					valueVector[0][currentPolicy->sequencesList[j]][i][m];
				else
				    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] +=
					valueVector[0][i][currentPolicy->sequencesList[j]][m];
			    }
			}
			k++;
		    }
		}
		i = 0;
		otherPolicy = policySetsList[a];
		while (i < policiesNumberList[a])
		{
                    //FRANS: this seems to perform evaluation of 'otherPolicy' ?! (see also line 634)
		    if (otherPolicy != currentPolicy)
		    {
			IloNumExpr constraintExpr (env);
			constraintExpr += variables[0];
			k = 0;
			for (j = 0; j < maxSequences[1 - a]; j++)
			{
			    if (sequencesList[0][1 - a][j] != NULL)
			    {
				for (m = 0; m < decpomdp.GetNrStates (); m++)
				{
				    otherPolicyValue = 0;
				    for (n = 0; n < otherPolicy->sequencesNumber; n++)
				    {
					if (a == 0)
					    otherPolicyValue += valueVector[0][otherPolicy->sequencesList[n]][j][m];
					else
					    otherPolicyValue += valueVector[0][j][otherPolicy->sequencesList[n]][m];
				    }
				    constraintExpr +=
					(variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] -
					 otherPolicyValue) * variables[m * sequencesNumberList[1 - a] + k + 1];
				}
				k++;
			    }
			}
			lpModel.add (constraintExpr >= 0);
			constraintExpr.end ();
		    }
		    otherPolicy = otherPolicy->next;
		    i++;
		}
		lpModel.add (IloMinimize (env, objectiveExpr));
		objectiveExpr.end ();
		IloCplex cplex (env);
		cplex.extract (lpModel);
		if (cplex.solve () == IloFalse)
		    exit (0);
		printf ("epsilon=%f\n", cplex.getValue (variables[0]));
		if (cplex.getValue (variables[0]) >= pruningThreshold)
		    isDominated = true;
		else
		    isDominated = false;

		variables.endElements ();
		lpModel.end ();
		cplex.end ();
		env.end ();
		// LP zone end *******************************************************************************

		if (isDominated == true)
		{
		    if (oldPolicy)
			oldPolicy->next = currentPolicy->next;
		    else
			policySetsList[a] = currentPolicy->next;
		    nextPolicy = currentPolicy;
		    // Delete this policy in the list of sequences
		    for (i = 0; i < currentPolicy->sequencesNumber; i++)
		    {
			sequencesList[0][a][currentPolicy->sequencesList[i]]->policiesNumber--;
			if (sequencesList[0][a][currentPolicy->sequencesList[i]]->policiesNumber == 0)
			{
			    sequencesList[0][a][currentPolicy->sequencesList[i]] = NULL;
			    sequencesNumberList[a]--;
			}
		    }
		    currentPolicy = currentPolicy->next;
		    policiesNumberList[a]--;
		}
		else
		{
		    oldPolicy = currentPolicy;
		    currentPolicy = currentPolicy->next;
		}
	    }
	    if (prunnedPoliciesNumber != 0)	// Some policies has been prunned
	    {
		finishedAgentsNumber = 0;
	    }
	    else
		finishedAgentsNumber++;

	    a = (a + 1) % decpomdp.GetNrAgents ();
	}

	for (i = 0; i < decpomdp.GetNrAgents (); i++)
	{
	    printf ("Agent %d has the following %d policies:\n", i, policiesNumberList[a]);
	    bestPolicy = policySetsList[i];
	    while (bestPolicy)
	    {
		displayPolicy (bestPolicy);
		bestPolicy = bestPolicy->next;
		printf ("\n");
	    }
	}

        Time.Stop("SolveHorizon1");
        ///FRANS: -----------------------end horizon 1----------------------------------

	// For the following horizons
	for (depth = 2; depth <= horizon; depth++)
	{
            stringstream ss;
            ss << "SolveHorizon" << depth;
            string SolveHorizonString=ss.str();
            Time.Start(SolveHorizonString);
	    // Generate the set of all possible policies of horizon=depth
	    for (a = 0; a < decpomdp.GetNrAgents (); a++)
	    {
		oldPolicySet = policySetsList[a];
		policiesNumberList[a] = 0;
		policySet = NULL;
		oldPolicy = NULL;
		i = 0;
		while (i < decpomdp.GetNrActions (a))
		{
		    k = 0;
		    j = 1;
		    while (k < decpomdp.GetNrObservations (a))
		    {
			//currentPolicy = (policyType *) malloc (sizeof (struct policyType));
			currentPolicy = new policyType(); 
			if (policySet == NULL)
			    policySet = currentPolicy;
                        //the following initializes an array of pointers, but not policyTypes themselves (so should be okay - no reason to call the policyTypes constructor...?)
			currentPolicy->subPolicyIndex = (policyType **) malloc (sizeof (struct policyType *) * decpomdp.GetNrJointObservations ());
                        
			currentPolicy->action = i;
			currentPolicy->next = NULL;
			if (oldPolicy)
			{
			    oldPolicy->next = currentPolicy;
			    currentPolicy->index = oldPolicy->index + 1;
			}
			else
			    currentPolicy->index = 0;
			currentPolicy->sequencesNumber = 0;

			if (j)
			{
			    policiesNumberList[a]++;
			    for (j = 0; j < decpomdp.GetNrObservations (a); j++)
			    {
				currentPolicy->subPolicyIndex[j] = oldPolicySet;
			    }
			    j = 0;
			    oldPolicy = currentPolicy;
			}
			else
			{
			    for (k = 0; k < decpomdp.GetNrObservations (a); k++)
			    {
				currentPolicy->subPolicyIndex[k] = oldPolicy->subPolicyIndex[k];
			    }

			    k = 0;
			    while ((k < decpomdp.GetNrObservations (a)) && (currentPolicy->subPolicyIndex[k]->next == NULL))
			    {
				currentPolicy->subPolicyIndex[k] = oldPolicySet;
				k++;
			    }
			    if (k < decpomdp.GetNrObservations (a))
			    {
				policiesNumberList[a]++;
				currentPolicy->subPolicyIndex[k] = currentPolicy->subPolicyIndex[k]->next;
				oldPolicy = currentPolicy;

			    }
			    else
			    {
				//free(currentPolicy->valueVector);
				//free(currentPolicy->subPolicyIndex);
				//free(currentPolicy);
				oldPolicy->next = NULL;
			    }
			}
		    }
		    i++;
		}
		currentPolicy->next = NULL;
		policySetsList[a] = policySet;

		sequencesNumberList[a] = 0;
		// Extend the sequences of the last iteration
		for (i = 0; i < decpomdp.GetNrActions (a); i++)
		{
		    for (j = 0; j < decpomdp.GetNrObservations (a); j++)
		    {
			for (k = 0; k < maxSequences[a]; k++)
			{
			    if (sequencesList[(depth) % 2][a][k] != NULL)
			    {
				currentSequence = (sequenceType *) malloc (sizeof (struct sequenceType));
				currentSequence->action = i;
				currentSequence->index = sequencesNumberList[a];
				currentSequence->observation = j;
				currentSequence->subSequence = sequencesList[(depth) % 2][a][k];
				currentSequence->policiesNumber = 0;
				sequencesList[(depth - 1) % 2][a][currentSequence->index] = currentSequence;
				sequencesNumberList[a]++;
				// Now find all the policies where this sequence appears
				currentPolicy = policySetsList[a];
				while (currentPolicy)
				{
				    if (currentPolicy->action == i)
				    {
					n = 0;
					while ((n < currentPolicy->subPolicyIndex[j]->sequencesNumber)
					       && (currentPolicy->subPolicyIndex[j]->sequencesList[n] != k))
					    n++;
					if (n < currentPolicy->subPolicyIndex[j]->sequencesNumber)
					{
					    currentSequence->policiesNumber++;
					    currentPolicy->sequencesList[currentPolicy->sequencesNumber] = currentSequence->index;
					    currentPolicy->sequencesNumber++;
					}
				    }
				    currentPolicy = currentPolicy->next;
				}
			    }
			}
		    }
		}
		maxSequences[a] = sequencesNumberList[a];
	    } //END OF Generate the set of all possible policies of horizon=depth

	    // Extend the C matrix and the Value Vectors
	    for (i = 0; i < sequencesNumberList[0]; i++)
	    {
		for (j = 0; j < sequencesNumberList[1]; j++)
		{
		    // Fill up the values of this joint sequence
		    jointAction =
			(decpomdp.GetNrActions (0)) * (sequencesList[(depth - 1) % 2][1][j]->action) + (sequencesList[(depth - 1) % 2][0][i]->action);
		    jointObservation =
			(decpomdp.GetNrObservations (0)) * (sequencesList[(depth - 1) % 2][1][j]->observation) +
			(sequencesList[(depth - 1) % 2][0][i]->observation);
		    for (int startState = 0; startState < decpomdp.GetNrStates (); startState++)
		    {
			valueVector[(depth - 1) % 2][i][j][startState] = 0;
			C[(depth - 1) % 2][i][j][startState] = 0;
			for (int arrivalState = 0; arrivalState < decpomdp.GetNrStates (); arrivalState++)
			{
			    valueVector[(depth - 1) % 2][i][j][startState] +=
				decpomdp.GetDiscount () * 
                                decpomdp.GetTransitionProbability (startState, jointAction, arrivalState) * 
                                decpomdp.GetObservationProbability (jointAction, arrivalState, jointObservation) *
                                valueVector
                                  [(depth) % 2]
                                  [sequencesList[(depth - 1) % 2][0][i]-> subSequence->index]
                                  [sequencesList[(depth - 1) % 2][1][j]->subSequence->index]
                                  [arrivalState];
			    C[(depth - 1) % 2][i][j][startState] +=
				decpomdp.GetTransitionProbability (startState, jointAction, arrivalState) * 
                                decpomdp.GetObservationProbability (jointAction, arrivalState, jointObservation) *
                                C
                                  [(depth) % 2]
                                  [sequencesList[(depth - 1) % 2][0][i]->subSequence->index]
                                  [sequencesList[(depth - 1) % 2][1][j]->subSequence->index]
                                  [arrivalState];
			}
		    }
		    for (int startState = 0; startState < decpomdp.GetNrStates (); startState++)
		    {
			valueVector[(depth - 1) % 2][i][j][startState] +=
			    decpomdp.GetReward (startState, jointAction) * C[(depth - 1) % 2][i][j][startState];
		    }
		}
	    }

            stringstream ss2;
            ss2 << "PruneDominatedPolicies" << depth;
            string PruneDominatedPoliciesString=ss2.str();
            Time.Start(PruneDominatedPoliciesString);
            // Boularias: " I also didn't prune policies in the last step."
            // FRANS:   this actually matters a lot if we still have to verify the value of all joint policies...            
            //          to fix that we change this
            //if (depth < horizon)
            //          to:
#if COMPUTE_VALUE
            if (depth <= horizon)
#else
            if (depth < horizon)
#endif
	    {
		// Prunning the dominated policies
		a = 0;
		finishedAgentsNumber = 0;
		while (finishedAgentsNumber < decpomdp.GetNrAgents ())
		{
		    prunnedPoliciesNumber = 0;
		    // Prun the dominated policies for agent a
		    currentPolicy = policySetsList[a];
		    oldPolicy = NULL;
		    while (currentPolicy)
		    {
			// LP zone begin ***************************************************************************
			// Evaluation according to the sequential representation
			IloEnv env;
			IloModel lpModel (env);
			IloNumVarArray variables (env);
			IloNumExpr objectiveExpr (env);
			variables.add (IloNumVar (env, -IloInfinity, IloInfinity));
			objectiveExpr += variables[0];
			for (i = 1; i < 1 + decpomdp.GetNrStates () * sequencesNumberList[1 - a]; i++)
			    variables.add (IloNumVar (env, 0, 1));
			double *variablesWeightsSaver =
			    (double *) malloc (sizeof (double) * (1 + decpomdp.GetNrStates () * sequencesNumberList[1 - a]));

			k = 0;
			for (i = 0; i < maxSequences[1 - a]; i++)
			{
			    if (sequencesList[(depth - 1) % 2][1 - a][i] != NULL)
			    {
				for (m = 0; m < decpomdp.GetNrStates (); m++)
				{
				    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] = 0;
				    for (j = 0; j < currentPolicy->sequencesNumber; j++)
				    {
					if (a == 0)
					    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] +=
						valueVector[(depth - 1) % 2][currentPolicy->sequencesList[j]][i][m];
					else
					    variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] +=
						valueVector[(depth - 1) % 2][i][currentPolicy->sequencesList[j]][m];
				    }
				}
				k++;
			    }
			}
			i = 0;
			otherPolicy = policySetsList[a];
			while (i < policiesNumberList[a])
			{
                            //FRANS: this seems to perform evaluation of 'otherPolicy' ?! (see also line 323)
			    if (otherPolicy != currentPolicy)
			    {
				IloNumExpr constraintExpr (env);
				constraintExpr += variables[0];
				k = 0;
				for (j = 0; j < maxSequences[1 - a]; j++)
				{
				    if (sequencesList[(depth - 1) % 2][1 - a][j] != NULL)
				    {
					for (m = 0; m < decpomdp.GetNrStates (); m++)
					{
					    otherPolicyValue = 0;
					    for (n = 0; n < otherPolicy->sequencesNumber; n++)
					    {
						if (a == 0)
						    otherPolicyValue += valueVector[(depth - 1) % 2][otherPolicy->sequencesList[n]][j][m];
						else
						    otherPolicyValue += valueVector[(depth - 1) % 2][j][otherPolicy->sequencesList[n]][m];
					    }
					    constraintExpr +=
						(variablesWeightsSaver[m * sequencesNumberList[1 - a] + k + 1] -
						 otherPolicyValue) * variables[m * sequencesNumberList[1 - a] + k + 1];
					}
					k++;
				    }
				}
				lpModel.add (constraintExpr >= 0);
				constraintExpr.end ();
			    }
			    otherPolicy = otherPolicy->next;
			    i++;
			}

			lpModel.add (IloMinimize (env, objectiveExpr));
			objectiveExpr.end ();
			IloCplex cplex (env);
			cplex.extract (lpModel);
			//for(i=1;i<decpomdp.GetNrStates()*sequencesNumberList[1-a]+1;i++)printf("(%d, %f)      ",i,variablesWeightsSaver[i]);
			//printf("\n");
			if (cplex.solve () == IloFalse)
			    exit (0);
			printf ("epsilon=%f\n", cplex.getValue (variables[0]));
			if (cplex.getValue (variables[0]) >= pruningThreshold)
			    isDominated = true;
			else
			    isDominated = false;

			variables.endElements ();
			lpModel.end ();
			cplex.end ();
			env.end ();
			// LP zone end *******************************************************************************

			if (isDominated == true)
			{
			    if (oldPolicy)
				oldPolicy->next = currentPolicy->next;
			    else
				policySetsList[a] = currentPolicy->next;
			    nextPolicy = currentPolicy;
			    // Delete this policy in the list of sequences
			    for (i = 0; i < currentPolicy->sequencesNumber; i++)
			    {
				sequencesList[(depth - 1) % 2][a][currentPolicy->sequencesList[i]]->policiesNumber--;
				if (sequencesList[(depth - 1) % 2][a][currentPolicy->sequencesList[i]]->policiesNumber == 0)
				{
				    sequencesList[(depth - 1) % 2][a][currentPolicy->sequencesList[i]] = NULL;
				    sequencesNumberList[a]--;
				}
			    }
			    currentPolicy = currentPolicy->next;
			    policiesNumberList[a]--;
			}
			else
			{
			    oldPolicy = currentPolicy;
			    currentPolicy = currentPolicy->next;
			}
		    }
		    if (prunnedPoliciesNumber != 0)	// Some policies has been prunned
		    {
			finishedAgentsNumber = 0;
		    }
		    else
			finishedAgentsNumber++;
		    a = (a + 1) % decpomdp.GetNrAgents ();
		}
	    }
            Time.Stop(PruneDominatedPoliciesString);

            stringstream ss1;
            ss1 << "Compression" << depth;
            string CompressionString=ss1.str();
            Time.Start(CompressionString);

	    //for(i=0;i<decpomdp.GetNrAgents();i++)
	    //{
	    //      printf("Agent %d has the following %d policies:\n",i,policiesNumberList[i]);
	    //      bestPolicy=policySetsList[i];
	    //      while(bestPolicy){displayPolicy(bestPolicy);bestPolicy=bestPolicy->next;printf("\n");}
	    //}
	    // Time for Compression!!!!!!!!!!!!
	    if ((policiesNumberList[0] <= sequencesNumberList[0]) && (policiesNumberList[1] <= sequencesNumberList[1]))
	    {
		int rowsIndex[150];
		float w[150];
		float buffer;
		int min;
		for (a = 0; a < 2; a++)
		{
		    k = 0;
		    for (i = 0; i < maxSequences[a]; i++)
		    {
			if (sequencesList[(depth - 1) % 2][a][i] != NULL)
			{
			    currentPolicy = policySetsList[a];
			    j = 0;
			    while (currentPolicy)
			    {
				n = 0;
				while ((n < currentPolicy->sequencesNumber) && (currentPolicy->sequencesList[n] != i))
				    n++;
				if (n < currentPolicy->sequencesNumber)
				    U[j][k] = 1;
				else
				    U[j][k] = 0;
				currentPolicy = currentPolicy->next;
				j++;
			    }
			    rowsIndex[k++] = i;
			}
		    }
		    //printf("U:\n");
		    //for(n=0;n<policiesNumberList[a];n++)
		    //{
		    //      for(j=0;j<sequencesNumberList[a];j++)
		    //      {
		    //              printf("%2.1f ",U[n][j]);
		    //      }
		    //      printf("\n");
		    //}

		    // Echlonement;
		    i = 0;
		    while ((i < policiesNumberList[a] - 1) && (i < sequencesNumberList[a] - 1) && (policiesNumberList[a] < sequencesNumberList[a]))
		    {
			j = i;
			while ((j < policiesNumberList[a]) && (U[j][i] == 0))
			    j++;
			if (j < policiesNumberList[a])
			{
			    if (j > i)
			    {
				for (n = 0; n < sequencesNumberList[a]; n++)
				{
				    buffer = U[i][n];
				    U[i][n] = U[j][n];
				    U[j][n] = buffer;
				}
			    }
			    for (j = i + 1; j < policiesNumberList[a]; j++)
			    {
				buffer = U[j][i];
				for (n = i; n < sequencesNumberList[a]; n++)
				    U[j][n] = U[j][n] * U[i][i] - U[i][n] * buffer;
			    }
			}
			if (U[i][i] == 0)
			{	// This sequence is dependent
			    if (i < policiesNumberList[a])
				min = i;
			    else
				min = policiesNumberList[a];
			    k = min - 1;
			    while (k >= 0)
			    {
				buffer = U[k][i];
				for (j = min - 1; j > k; j--)
				    buffer = buffer - w[j] * U[k][j];
				if (U[k][k] != 0)
				{
				    w[k] = buffer / U[k][k];
				    for (n = 0; n < maxSequences[1 - a]; n++)
				    {
					if (sequencesList[(depth - 1) % 2][1 - a][n] != NULL)
					{
					    for (int state = 0; state < decpomdp.GetNrStates (); state++)
					    {
						if (a == 1)
						{
						    C[(depth - 1) % 2][n][rowsIndex[k]][state] += w[k] * C[(depth - 1) % 2][n][rowsIndex[i]][state];
						    valueVector[(depth - 1) % 2][n][rowsIndex[k]][state] +=
							w[k] * valueVector[(depth - 1) % 2][n][rowsIndex[i]][state];
						}
						else
						{
						    C[(depth - 1) % 2][rowsIndex[k]][n][state] += w[k] * C[(depth - 1) % 2][rowsIndex[i]][n][state];
						    valueVector[(depth - 1) % 2][rowsIndex[k]][n][state] +=
							w[k] * valueVector[(depth - 1) % 2][rowsIndex[i]][n][state];
						}
					    }
					}
				    }
				}
				else
				{
				    w[k] = 0;
				}
				k--;
			    }
			    // Remove this sequence from all the policies
			    sequencesList[(depth - 1) % 2][a][rowsIndex[i]] = NULL;
			    currentPolicy = policySetsList[a];
			    while (currentPolicy)
			    {
				n = 0;
				while ((n < currentPolicy->sequencesNumber) && (currentPolicy->sequencesList[n] != rowsIndex[i]))
				    n++;
				if (n < currentPolicy->sequencesNumber)
				{
				    while (n < currentPolicy->sequencesNumber - 1)
					currentPolicy->sequencesList[n] = currentPolicy->sequencesList[++n];
				    currentPolicy->sequencesNumber--;
				}
				currentPolicy = currentPolicy->next;
				j++;
			    }
			    // Shift the matrix U and the vector rowsIndex
			    for (n = i; n < sequencesNumberList[a] - 1; n++)
				rowsIndex[n] = rowsIndex[n + 1];
			    for (k = 0; k < policiesNumberList[a]; k++)
			    {
				for (n = i; n < sequencesNumberList[a] - 1; n++)
				    U[k][n] = U[k][n + 1];
			    }
			    sequencesNumberList[a]--;
			}
			else
			    i++;
			//printf("U:\n");
			//for(n=0;n<policiesNumberList[a];n++)
			//{
			//      for(j=0;j<sequencesNumberList[a];j++)
			//      {
			//              printf("%2.1f ",U[n][j]);
			//      }
			//      printf("\n");
			//}
		    }
		    i = policiesNumberList[a];
		    while (policiesNumberList[a] < sequencesNumberList[a])
		    {		// This sequence is dependent
			if (i < policiesNumberList[a])
			    min = i;
			else
			    min = policiesNumberList[a];
			k = min - 1;
			while (k >= 0)
			{
			    buffer = U[k][i];
			    for (j = min - 1; j > k; j--)
				buffer = buffer - w[j] * U[k][j];
			    if (U[k][k] != 0)
			    {
				w[k] = buffer / U[k][k];
				for (n = 0; n < maxSequences[1 - a]; n++)
				{
				    if (sequencesList[(depth - 1) % 2][1 - a][n] != NULL)
				    {
					for (int state = 0; state < decpomdp.GetNrStates (); state++)
					{
					    if (a == 1)
					    {
						C[(depth - 1) % 2][n][rowsIndex[k]][state] += w[k] * C[(depth - 1) % 2][n][rowsIndex[i]][state];
						valueVector[(depth - 1) % 2][n][rowsIndex[k]][state] +=
						    w[k] * valueVector[(depth - 1) % 2][n][rowsIndex[i]][state];
					    }
					    else
					    {
						C[(depth - 1) % 2][rowsIndex[k]][n][state] += w[k] * C[(depth - 1) % 2][rowsIndex[i]][n][state];
						valueVector[(depth - 1) % 2][rowsIndex[k]][n][state] +=
						    w[k] * valueVector[(depth - 1) % 2][rowsIndex[i]][n][state];
					    }
					}
				    }
				}
			    }
			    else
			    {
				w[k] = 0;
			    }
			    k--;
			}
			// Remove this sequence from all the policies
			sequencesList[(depth - 1) % 2][a][rowsIndex[i]] = NULL;
			sequencesNumberList[a]--;
			currentPolicy = policySetsList[a];
			while (currentPolicy)
			{
			    n = 0;
			    while ((n < currentPolicy->sequencesNumber) && (currentPolicy->sequencesList[n] != rowsIndex[i]))
				n++;
			    if (n < currentPolicy->sequencesNumber)
			    {
				while (n < currentPolicy->sequencesNumber - 1)
				    currentPolicy->sequencesList[n] = currentPolicy->sequencesList[++n];
				currentPolicy->sequencesNumber--;
			    }
			    currentPolicy = currentPolicy->next;
			    j++;
			}
			// Shift the matrix U and the vector w
			for (n = i; n < sequencesNumberList[a] - 1; n++)
			    w[n] = w[n + 1];
			for (k = 0; k < policiesNumberList[a]; k++)
			{
			    for (n = i; n < sequencesNumberList[a] - 1; n++)
				U[k][n] = U[k][n + 1];
			}
			i++;
		    }
		}
	    }
            Time.Stop(CompressionString);
            Time.Stop(SolveHorizonString);
	    // End of Compression
	}

	ftime (&end);

	printf ("Running time: %d ms\n", (end.time - start.time) * 1000 + end.millitm - start.millitm);
	printf ("Agent 1 has the following %d policies:\n", policiesNumberList[0]);
	printf ("Agent 2 has the following %d policies:\n", policiesNumberList[1]);

	printf ("\nAgent 1 has the following %d sequences:\n", sequencesNumberList[0]);
	printf ("Agent 2 has the following %d sequences:\n", sequencesNumberList[1]);




// -policySetsList[0] and policySetsList[0] are the sets of policies
//  for the two agents. 
// -The optimal value can be found by going through all the joint policies (i,j) and calculating their values given initialBeliefState. 
// -The value of a joint policy (i,j) in state s is the sum of the values of all joint sequences (n,m) that were not
//  removed (independent) and that appear in (i,j).  
// -The number of sequences of policy i is (i->sequencesNumber), 
// -a sequence indexed by n is removed if (sequencesList[(depth-1)%2][a][n]==NULL), 
// -the indexes of sequences that appear in policy i are in the array (i->sequencesList). 
// -The value of a joint sequence (n,m) in state s is valueVector[(depth-1)%2][n][m][s].  
//  (I used this [(depth-1)%2] just because I needed to always save the current
//  and previous values, and I didn't want to do copies of the sort
//  oldValue[depth]=newValue[depth-1].


// CALCULATE VALUE

//-------------------------------------------------------------------------
// FRANS: questions/assumptions:
// - from "otherPolicy = policySetsList[a]; [...]  otherPolicy = otherPolicy->next; " I infer that the policies themselves
//   are the elements in a linked list, right? 
//
//      Boularias:  Yes, the policies are in a linked list (this helps deleting dominated policies in o(1)). 
//                  You can do "otherPolicy = policySetsList[a];  otherPolicy = otherPolicy->next;"
//
// - in sequencesList[0][1][j]...
//      ...what is the first index (the '0') ???
//
//          Boularias: This is a trick that I used for avoiding moving of copies. 
//          Initially (depth=0), the sequences are all in sequencesList[0]. 
//          Then, the one-step extension of these sequences (depth=1) are in sequencesList[1]. 
//          The sequences of depth 3 are in sequencesList[0], and those of depth 4 are in sequencesList[1]. 
//          Therefore, you should look at sequencesList[(depth) % 2] to find the sequences of length "depth". 
//          At the end, depth is given by the planning horizon (depth=0 <=> one action).
//
//          Boularias: The second index is the agent (0 or 1). 
//
//      ...what exactly is j? 
//          Boularias: The last index is the index of a sequence, ranging from 0 to maxSequences[agentIndex].
//
//-------------------------------------------------------------------------

//
#define FRANS_DEBUG 0

#if COMPUTE_VALUE
        Time.Start("DetermineValueOfSolution");
int numPolsAgent0 = policiesNumberList[0];
int numPolsAgent1 = policiesNumberList[1];

//see Boularias' explanation above
//horizon 1 <-> one action <-> depth=0 (so subtracting 1 of horizon to get depth)
int magic_depth_index = (horizon - 1) % 2;

double max_v = -DBL_MAX;

int pol0Index = 0; //index of the policy of agent 0 in its set of policies
policyType * policyAgent0 = policySetsList[0]; 
while (pol0Index < numPolsAgent0)
{
#if FRANS_DEBUG
    cout << "Next agent 0 policy..." << endl;
#endif

    int pol1Index = 0; //index of the policy of agent 1 in its set of policies
    policyType * policyAgent1 = policySetsList[1]; 
    while (pol1Index < numPolsAgent1)
    {
#if FRANS_DEBUG
        cout << "Next agent 1 policy..." << endl;
#endif

        //Now calculate value for (policyAgent0, policyAgent1):
        double valueJPol = 0.0;
        

        //loop over policyAgent0's sequences
        int numSeqsPol0 = policyAgent0->sequencesNumber;
        int numSeqsPol1 = policyAgent1->sequencesNumber;
        // the sequences themselves are stored in the array policyAgent0->sequencesList
        // (FRANS: I think this is just an array of ints...?)
        for(int i=0; i < numSeqsPol0; i++)
        {
            int seq0Index = policyAgent0->sequencesList[i];
            if (sequencesList[magic_depth_index][0][seq0Index] == NULL)
                continue; //this sequence was prunded: skip to next sequence
#if FRANS_DEBUG
            cout << "policyAgent0->sequencesList["<< i <<"] = " << seq0Index << endl;
#endif
            for(int j=0; j < numSeqsPol1; j++)
            {
                int seq1Index = policyAgent1->sequencesList[j];
                if (sequencesList[magic_depth_index][1][seq1Index] == NULL)
                    continue; //this sequence was prunded: skip to next sequence
#if FRANS_DEBUG
                cout << "policyAgent1->sequencesList["<< j <<"] = " << seq1Index << endl;
#endif

                //compute the value for this joint sequence:
                double valueJointSequence = 0.0;
                for (int state_index=0; state_index < decpomdp.GetNrStates(); state_index++)
                {
                    double v_s = valueVector[magic_depth_index][seq0Index][seq1Index][state_index]; 
#if FRANS_DEBUG
                    cout << "v_s=" << v_s << endl;
#endif
                    valueJointSequence += v_s * decpomdp.GetInitialStateProbability(state_index);
                }
#if FRANS_DEBUG
                cout << "value jseq=" << valueJointSequence << endl;
#endif
                valueJPol += valueJointSequence; 
            }
        }
#if FRANS_DEBUG
        cout << "value jpol=" << valueJPol << endl;
#endif
        if(valueJPol > max_v)
            max_v = valueJPol;

        /*  OLD
	for (seq0Index = 0; seq0Index < maxSequences[0]; seq0Index++) // this must be wrong, these sequences are not particular to policyAgent0!! - instead we should probably loop over "policyAgent0->sequencesList" but *how* ???
	{
            //: check if sequence not 'deleted' ???
            if (sequencesList[0][0][seq0Index] == NULL)
                continue; //: skip to next sequence?
            //loop over policyAgent1's sequences
            int numSeqsPol1 = policyAgent1->sequencesNumber;
	    for (seq1Index = 0; seq1Index < maxSequences[1]; seq1Index++)
	    {
                //: check if sequence not 'deleted' ???
                if (sequencesList[0][1][seq1Index] == NULL)
                    continue; //: skip to next sequence?
                double valueJointSequence = 0.0;
                for (int state_index=0; state_index < NUMBER_OF_STATES; state_index++)
                {
                    v_s = valueVector[0][seq0Index][seq1Index][state_index]; 
                    valueJointSequence += v_s * INITIAL_BELIEF(state_index);
                }
                valueJPol += valueJointSequence; //  - or do we still need to weight this?
	    }
	}
        */


        policyAgent1 = policyAgent1->next;
        pol1Index++;
    }
    policyAgent0 = policyAgent0->next;
    pol0Index++;
}

cout << "best jpol has value " << max_v << endl;
        Time.Stop("DetermineValueOfSolution");

//-------------------------------------------------------------------------

        OptimalValueDatabase db(decpomdp.GetUnixName(),
                                decpomdp.GetDiscount(),
                                args.horizon);
        if(db.IsInDatabase())
        {
            if(!db.IsOptimal(max_v))
            {
                double diff=abs(max_v-db.GetOptimalValue());
                stringstream ss;
                ss << "DP-LPC error, computed value " << max_v
                   << " does not match"
                   << " previously computed optimal value "
                   << db.GetOptimalValue() << ", difference is "
                   << diff;
                cout << ss.str() << endl;
                if(diff>1e-6)
                    throw(E(ss.str()));
            }
//            else
//                db.SetOptimalValue(V);
        }

#endif // COMPUTE_VALUE
	Time.Stop("Planning");

	if (args.verbose >= 0)
	{
	    Time.PrintSummary ();
	    // gmaa->PrintTimersSummary();
	}
	if (!args.dryrun)
        {
#if COMPUTE_VALUE
            *fp << max_v << endl;
#else
            *fp << "value not computed" << endl;
#endif
	    Time.Save(timingsFilename);
        }
}


int
main (int argc, char **argv)
{
    ArgumentHandlers::Arguments args;
    argp_parse (&ArgumentHandlers::theArgpStruc, argc, argv, 0, 0, &args);

    srand (time (0));

    int horizon = args.horizon;

    try
    {
	//start timers
	Timing Time;
	Time.Start("Overall");

	const DecPOMDPDiscreteInterface & decpomdp = *GetDecPOMDPDiscreteInterfaceFromArgs (args);

	//set the filename etc.
	string filename = "/dev/null", timingsFilename = "/dev/null";
        directories::MADPCreateResultsDir("DP-LPC",decpomdp);
	stringstream ss;
	ss << directories::MADPGetResultsFilename ("DP-LPC", decpomdp, args) << "h" << horizon;

        //cout << "maxSequencesNumber= " << maxSequencesNumber << endl;
        ComputeSeqsNumbers(decpomdp, horizon);
        cout << "maxSequencesNumber= " << maxSequencesNumber << endl;

        ofstream *fp=0;
	if (!args.dryrun)
	{
	    filename = ss.str ();
	    timingsFilename = filename + "_Timings";
            cout << "Computing " << ss.str() << endl;
            fp=new ofstream(filename.c_str());
            if(!*fp)
            {
                stringstream ss;
                ss << "DPLPC: failed to open file " << filename << endl;
                throw E(ss.str());
            }
            fp->precision(16);
	}

        for(Index i=0;i!=args.nrRestarts;++i)
        {
            DPLPCrun(decpomdp,fp,Time,horizon,args,timingsFilename);
        }

	Time.Stop ("Overall");

	if (!args.dryrun)
	    Time.Save(timingsFilename);

    }
    catch (E & e)
    {
	e.Print ();
    }
}

#else //if not HAVE_CPLEX
int
main (int argc, char **argv)
{
    std::cout << "DP-LPC requires CPLEX, but compiled without CPLEX support" << std::endl;
}
#endif
